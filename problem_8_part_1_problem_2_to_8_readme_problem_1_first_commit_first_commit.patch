Subject: [PATCH] problem 8 part 1
problem 2 to 8
readme
problem 1
first commit
first commit
---
Index: README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/README.md b/README.md
new file mode 100644
--- /dev/null	(revision 268da21ec7a168b359517d17d039970e8bd4cc83)
+++ b/README.md	(revision 268da21ec7a168b359517d17d039970e8bd4cc83)
@@ -0,0 +1,24 @@
+# advent-of-code
+
+hacky and quick Java solutions to Advent Of Code.
+
+This isn't maintainable, tested, or sometimes even readable or performant code, but nobody reads this anyway :-)
+
+
+## Progress
+
+| problem | Part One | Part Two |
+|---------|------|----|
+| 1       | ✅    |     ✅ |
+| 2       | ✅    |     ✅ |
+| 3       |      ✅ |    ✅ |
+| 4       |     ✅ |   ✅ |
+| 5       |     ✅ |    |
+| 6       |     ✅ |   ✅ |
+| 7       |     ✅ |   ✅ |
+| 8       |     ✅ |    |
+| 9       |      |    |
+| 10      |      |    |
+| 11      |      |    |
+| 12      |      |    |
+
Index: src/main/java/com/wdtr/aoc/_2023/Problem1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Problem1.java b/src/main/java/com/wdtr/aoc/_2023/Problem1.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Problem1.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,93 @@
+package com.wdtr.aoc._2023;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Stream;
+
+public class Problem1 {
+
+    public static void main(String[] args) {
+        String filePath = "src/main/resources/aoc-2023/problem1/input.txt";
+        Path path = Path.of(filePath);
+        try (Stream<String> lines = Files.lines(path)) {
+            System.out.printf("Solution part 1: %d%n", lines.mapToInt(Problem1::cleanupCalibrationValuePartOne).sum());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        try (Stream<String> lines = Files.lines(path)) {
+            System.out.printf("Solution part 2: %d%n", lines.mapToInt(Problem1::cleanupCalibrationValuePartTwo).sum());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static int cleanupCalibrationValuePartTwo(String line) {
+        Map<String, Character> digitsMap = Map.of(
+                "one", '1',
+                "two", '2',
+                "three", '3',
+                "four", '4',
+                "five", '5',
+                "six", '6',
+                "seven", '7',
+                "eight", '8',
+                "nine", '9'
+                );
+        char[] nums = new char[2];
+        boolean foundFirst = false;
+        String possibleDigitWord = "";
+        for (char c : line.toCharArray()) {
+            possibleDigitWord += c;
+            Optional<Character> optionalC = isDigit(digitsMap, possibleDigitWord);
+            if(optionalC.isPresent()) {
+                setNumber(nums, optionalC.get(), foundFirst);
+                possibleDigitWord = String.valueOf(c);
+                foundFirst = true;
+            }
+            else if(isNum(c)) {
+                setNumber(nums, c, foundFirst);
+                possibleDigitWord = "";
+                foundFirst = true;
+            }
+        }
+        return Integer.parseInt(String.valueOf(nums));
+    }
+
+    private static Optional<Character> isDigit(Map<String, Character> digitsMap, String possibleDigitWord) {
+        for (String digit : digitsMap.keySet()) {
+            if(possibleDigitWord.contains(digit)) {
+                return Optional.of(digitsMap.get(digit));
+            }
+        }
+        return Optional.empty();
+    }
+
+    private static void setNumber(char[] nums, char numToSet, boolean foundFirst) {
+        if (!foundFirst) {
+            nums[0] = numToSet;
+        }
+        nums[1] = numToSet;
+    }
+
+    private static int cleanupCalibrationValuePartOne(String line) {
+        char[] nums = new char[2];
+        boolean foundFirst = false;
+        for (char c : line.toCharArray()) {
+            if (isNum(c)) {
+                if (!foundFirst) {
+                    nums[0] = c;
+                    foundFirst = true;
+                }
+                nums[1] = c;
+            }
+        }
+        return Integer.parseInt(String.valueOf(nums));
+    }
+
+    private static boolean isNum(char c) {
+        return c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9';
+    }
+}
\ No newline at end of file
Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/.gitignore	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,32 @@
+g### IntelliJ IDEA ###
+out/
+!**/src/main/**/out/
+!**/src/test/**/out/
+
+### Eclipse ###
+.apt_generated
+.classpath
+.factorypath
+.project
+.settings
+.springBeans
+.sts4-cache
+bin/
+!**/src/main/**/bin/
+!**/src/test/**/bin/
+
+### NetBeans ###
+/nbproject/private/
+/nbbuild/
+/dist/
+/nbdist/
+/.nb-gradle/
+
+### VS Code ###
+.vscode/
+
+### Mac OS ###
+.DS_Store
+/advent-of-code.iml
+/.idea/
+/src/main/resources/aoc-2023/
Index: src/main/java/com/wdtr/aoc/_2023/Pair.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Pair.java b/src/main/java/com/wdtr/aoc/_2023/Pair.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Pair.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,5 @@
+package com.wdtr.aoc._2023;
+
+public record Pair<F, S>(F first, S second) {
+
+}
\ No newline at end of file
Index: src/main/java/com/wdtr/aoc/_2023/Problem2.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Problem2.java b/src/main/java/com/wdtr/aoc/_2023/Problem2.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Problem2.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,77 @@
+package com.wdtr.aoc._2023;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.sql.SQLOutput;
+import java.util.Map;
+import java.util.stream.Stream;
+
+public class Problem2 {
+
+
+    public static void main(String[] args) {
+        String filePath = "src/main/resources/aoc-2023/problem2/input.txt";
+        Path path = Path.of(filePath);
+        try (Stream<String> lines = Files.lines(path)) {
+            System.out.printf("Solution part 1: " +  lines.mapToInt(Problem2::isValidLine).sum());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        System.out.println("");
+        try (Stream<String> lines = Files.lines(path)) {
+            System.out.printf("Solution part 2: " +  lines.mapToInt(Problem2::maxColorPerLineMultipliedByEachother).sum());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+    private static int isValidLine(String line) {
+        Map<String, Integer> maxColorMap = Map.of("red", 12,
+                "green", 13,
+                "blue", 14
+        );
+        String[] split = line.split(":");
+        String game = split[0];
+        String input = split[1];
+        String[] sets = input.split(";");
+        for (String set : sets) {
+            String[] numbersWithColors = set.split(",");
+            for (String numberWithColor : numbersWithColors) {
+                String[] numberWithColorSplit = numberWithColor.trim().split(" ");
+                int number = Integer.parseInt(numberWithColorSplit[0]);
+                String color = numberWithColorSplit[1];
+                if(number > maxColorMap.get(color)) {
+                    return 0;
+                }
+            }
+        }
+        return Integer.parseInt(game.split(" ")[1].replace(":",""));
+    }
+
+    private static int maxColorPerLineMultipliedByEachother(String line) {
+        String[] split = line.split(":");
+        String game = split[0];
+        String input = split[1];
+        String[] sets = input.split(";");
+        int maxRed = 0;
+        int maxGreen = 0;
+        int maxBlue = 0;
+        for (String set : sets) {
+            String[] numbersWithColors = set.split(",");
+            for (String numberWithColor : numbersWithColors) {
+                String[] numberWithColorSplit = numberWithColor.trim().split(" ");
+                int number = Integer.parseInt(numberWithColorSplit[0]);
+                String color = numberWithColorSplit[1];
+                if(color.equals("red")) {
+                    maxRed = Math.max(maxRed, number);
+                } else if (color.equals("green")) {
+                    maxGreen = Math.max(maxGreen, number);
+                } else {
+                    maxBlue = Math.max(maxBlue, number);
+                }
+            }
+        }
+        return maxRed * maxGreen * maxBlue;
+    }
+}
Index: src/main/java/com/wdtr/aoc/_2023/Problem3.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Problem3.java b/src/main/java/com/wdtr/aoc/_2023/Problem3.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Problem3.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,232 @@
+package com.wdtr.aoc._2023;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Stream;
+
+public class Problem3 {
+
+    public static void main(String[] args) {
+        String filePath = "src/main/resources/aoc-2023/problem3/input.txt";
+        Path path = Path.of(filePath);
+        // cat input.txt | head -n1 | wc -m
+        // cat input.txt | wc -l
+        char[][] engineSchematic = new char[140][140];
+        try (Stream<String> lines = Files.lines(path)) {
+            AtomicInteger lineIdx = new AtomicInteger();
+            lines.forEach(line -> {
+                        char[] charArray = line.toCharArray();
+                        for (int i = 0; i < charArray.length; i++) {
+                            engineSchematic[lineIdx.get()][i] = charArray[i];
+                        }
+                        lineIdx.getAndIncrement();
+                    }
+            );
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        System.out.println("Solution part one: " + calcSumOfPartNumbers(engineSchematic));
+        System.out.println("Solution part two: " + calcGearRatio(engineSchematic));
+    }
+
+    private static int calcSumOfPartNumbers(char[][] engineSchematic) {
+        int sum = 0;
+        for (int i = 0; i < engineSchematic.length; i++) {
+            String currNumSeq = "";
+            boolean isCurrSeqPartNumber = false;
+            for (int j = 0; j < engineSchematic[i].length; j++) {
+                char currChar = engineSchematic[i][j];
+                if (isNum(currChar)) {
+                    currNumSeq += currChar;
+                    // Only 1 num in the seq needs to be adjacent to a symbol for it to be a match in its whole.
+                    // That also means to not bother if we already found one char in the sequence to be adjacent to a symbol.
+                    if (!isCurrSeqPartNumber && isAdjacentToSymbol(i, j, engineSchematic)) {
+                        isCurrSeqPartNumber = true;
+                    }
+                } else {
+                    if (isCurrSeqPartNumber) {
+                        sum += Integer.parseInt(currNumSeq);
+                    }
+                    currNumSeq = "";
+                    isCurrSeqPartNumber = false;
+                }
+            }
+            if (isCurrSeqPartNumber) {
+                sum += Integer.parseInt(currNumSeq);
+            }
+        }
+        return sum;
+    }
+
+    private static boolean isAdjacentToSymbol(int i, int j, char[][] engineSchematic) {
+        boolean jInUpperBound = j + 1 < 140;
+        boolean jInLowerBound = j - 1 > 0;
+        boolean iInUpperBound = i + 1 < 140;
+        boolean iInLowerBound = i - 1 > 0;
+
+        if(jInUpperBound) {
+            char right = engineSchematic[i][j + 1];
+            if(isSymbol(right)) {
+                return true;
+            }
+            if(iInLowerBound) {
+                char diagAboveRight = engineSchematic[i - 1][j + 1];
+                if(isSymbol(diagAboveRight)) {
+                    return true;
+                }
+            }
+            if(iInUpperBound) {
+                char diagUnderRight = engineSchematic[i + 1][j + 1];
+                if(isSymbol(diagUnderRight)) {
+                    return true;
+                }
+            }
+        }
+        if(jInLowerBound) {
+            char left = engineSchematic[i][j - 1];
+            if(isSymbol(left)) {
+                return true;
+            }
+            if(iInLowerBound) {
+                char diagAboveLeft = engineSchematic[i - 1][j - 1];
+                if(isSymbol(diagAboveLeft)) {
+                    return true;
+                }
+            }
+            if(iInUpperBound) {
+                char diagUnderLeft = engineSchematic[i + 1][j - 1];
+                if(isSymbol(diagUnderLeft)) {
+                    return true;
+                }
+            }
+        }
+
+        if(iInLowerBound) {
+            char above = engineSchematic[i - 1][j];
+            if(isSymbol(above)) {
+                return true;
+            }
+        }
+
+        if(iInUpperBound) {
+            char under = engineSchematic[i + 1][j];
+            if(isSymbol(under)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    private static boolean isNum(char c) {
+        return c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9';
+    }
+
+    private static boolean isSymbol(char c) {
+        return c != '.' && !isNum(c);
+    }
+
+
+    // Part two:
+
+    private static int calcGearRatio(char[][] engineSchematic) {
+        Map<Pair<Integer, Integer>, List<Integer>> gearsWithAdjacentNumSeqsMap = new HashMap<>();
+        for (int i = 0; i < engineSchematic.length; i++) {
+            String currNumSeq = "";
+            Set<Pair<Integer, Integer>> gearAdjacencies = new HashSet<>();
+            for (int j = 0; j < engineSchematic[i].length; j++) {
+                char currChar = engineSchematic[i][j];
+                if (isNum(currChar)) {
+                    currNumSeq += currChar;
+                    gearAdjacencies.addAll(findGearAdjacencies(i, j, engineSchematic));
+                } else {
+                    addAdjacentNumSeqsOfGearToMap(gearsWithAdjacentNumSeqsMap, currNumSeq, gearAdjacencies);
+                    currNumSeq = "";
+                    gearAdjacencies.clear();
+                }
+            }
+            addAdjacentNumSeqsOfGearToMap(gearsWithAdjacentNumSeqsMap, currNumSeq, gearAdjacencies);
+        }
+
+
+        return gearsWithAdjacentNumSeqsMap.values().stream().filter(numseqs -> numseqs.size() == 2)
+                .map(numseq -> numseq.get(0) * numseq.get(1))
+                .mapToInt(Integer::intValue)
+                .sum();
+    }
+
+    public static void addAdjacentNumSeqsOfGearToMap(Map<Pair<Integer, Integer>, List<Integer>> gearsWithAdjacentNumSeqsMap, String numSeq, Set<Pair<Integer, Integer>> gearAdjacencies) {
+        for (Pair<Integer, Integer> gearAdjacency : gearAdjacencies) {
+            if(!gearsWithAdjacentNumSeqsMap.containsKey(gearAdjacency)) {
+                gearsWithAdjacentNumSeqsMap.put(gearAdjacency, new ArrayList<>());
+            }
+            gearsWithAdjacentNumSeqsMap.get(gearAdjacency).add(Integer.parseInt(numSeq));
+        }
+    }
+    private static boolean isGear(char c) {
+        return c == '*';
+    }
+    private static Set<Pair<Integer, Integer>> findGearAdjacencies(int i, int j, char[][] engineSchematic) {
+        boolean jInUpperBound = j + 1 < 140;
+        boolean jInLowerBound = j - 1 > 0;
+        boolean iInUpperBound = i + 1 < 140;
+        boolean iInLowerBound = i - 1 > 0;
+
+        Set<Pair<Integer, Integer>> gearAdjs = new HashSet<>();
+        if(jInUpperBound) {
+            char right = engineSchematic[i][j + 1];
+            if(isGear(right)) {
+                gearAdjs.add(new Pair<>(i, j +1));
+            }
+            if(iInLowerBound) {
+                char diagAboveRight = engineSchematic[i - 1][j + 1];
+                if(isGear(diagAboveRight)) {
+                    gearAdjs.add(new Pair<>(i - 1, j +1));
+                }
+            }
+            if(iInUpperBound) {
+                char diagUnderRight = engineSchematic[i + 1][j + 1];
+                if(isGear(diagUnderRight)) {
+                    gearAdjs.add(new Pair<>(i + 1, j +1));
+                }
+            }
+        }
+        if(jInLowerBound) {
+            char left = engineSchematic[i][j - 1];
+            if(isGear(left)) {
+                gearAdjs.add(new Pair<>(i, j - 1));
+            }
+            if(iInLowerBound) {
+                char diagAboveLeft = engineSchematic[i - 1][j - 1];
+                if(isGear(diagAboveLeft)) {
+                    gearAdjs.add(new Pair<>(i - 1, j - 1));
+                }
+            }
+            if(iInUpperBound) {
+                char diagUnderLeft = engineSchematic[i + 1][j - 1];
+                if(isGear(diagUnderLeft)) {
+                    gearAdjs.add(new Pair<>(i + 1, j - 1));
+                }
+            }
+        }
+
+        if(iInLowerBound) {
+            char above = engineSchematic[i - 1][j];
+            if(isGear(above)) {
+                gearAdjs.add(new Pair<>(i - 1, j));
+            }
+        }
+
+        if(iInUpperBound) {
+            char under = engineSchematic[i + 1][j];
+            if(isGear(under)) {
+                gearAdjs.add(new Pair<>(i + 1, j));
+            }
+        }
+        return gearAdjs;
+    }
+
+}
Index: src/main/java/com/wdtr/aoc/_2023/Problem4.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Problem4.java b/src/main/java/com/wdtr/aoc/_2023/Problem4.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Problem4.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,84 @@
+package com.wdtr.aoc._2023;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static java.util.function.Predicate.not;
+
+public class Problem4 {
+
+    public static void main(String[] args) {
+        String filePath = "src/main/resources/aoc-2023/problem4/input.txt";
+        Path path = Path.of(filePath);
+        // cat input.txt | head -n1 | wc -m
+        // cat input.txt | wc -l
+        List<CardLine> cardLines = new ArrayList<>();
+        try (Stream<String> lines = Files.lines(path)) {
+            cardLines = lines.map(Problem4::parseToCardLine).toList();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        System.out.println("Solution part one: " + cardLines.stream().map(CardLine::calculatePointsPartOne).mapToInt(Integer::intValue).sum());
+        System.out.println("Solution part two: " + calculateCopiesOfScratchCards(cardLines));
+    }
+
+    private static int calculateCopiesOfScratchCards(List<CardLine> cardLines) {
+        Map<Integer, Integer> cardIdxToAmountOfCopiesMap = new HashMap<>();
+        int copies = 0;
+        for (int i = 0; i < cardLines.size(); i++) {
+            int amountOfInstances = cardIdxToAmountOfCopiesMap.getOrDefault(i, 1);
+            CardLine currCardLine = cardLines.get(i);
+            int pointsForCurrCard = currCardLine.calculatePointsPartTwo();
+            for (int j = 1; j <= pointsForCurrCard; j++) {
+                Integer valueInNextCard = cardIdxToAmountOfCopiesMap.getOrDefault(i + j, 1);
+                cardIdxToAmountOfCopiesMap.put(i + j, valueInNextCard + amountOfInstances);
+            }
+            copies += amountOfInstances;
+        }
+        return copies;
+    }
+
+    private static CardLine parseToCardLine(String line) {
+        String[] split = line.split(":")[1].split("\\|");
+        return new CardLine(parseNumbersToSet(split[0]), parseNumbersToSet(split[1]));
+    }
+
+    private static Set<Integer> parseNumbersToSet(String numbers) {
+        String[] split = numbers.split(" ");
+        return Arrays.stream(split).filter(not(s -> s.equals(" ") || s.isEmpty())).map(Integer::parseInt).collect(Collectors.toSet());
+    }
+
+
+    record CardLine(Set<Integer> winningNumbers, Set<Integer> numbersInHand) {
+
+        public int calculatePointsPartOne() {
+            int count = 0;
+            for (Integer number : numbersInHand) {
+                if (winningNumbers.contains(number)) {
+                    count++;
+                }
+            }
+            if (count == 0) {
+                return 0;
+            }
+            return (int) Math.pow(2, count - 1);
+        }
+
+        public int calculatePointsPartTwo() {
+            int count = 0;
+            for (Integer number : numbersInHand) {
+                if (winningNumbers.contains(number)) {
+                    count++;
+                }
+            }
+            return count;
+        }
+    }
+
+
+}
Index: src/main/java/com/wdtr/aoc/_2023/Problem5.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Problem5.java b/src/main/java/com/wdtr/aoc/_2023/Problem5.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Problem5.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,148 @@
+package com.wdtr.aoc._2023;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.sql.SQLOutput;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class Problem5 {
+
+    // It'd be easy to just store everything in maps linking to eachother, but as we can see in the input data,
+    // the ranges get rather high, so we will have to optimize a bit.
+    public static void main(String[] args) {
+        String filePath = "src/main/resources/aoc-2023/problem5/input.txt";
+        Path path = Path.of(filePath);
+        SeedTransformer seedTransformer = null;
+        try (Stream<String> lines = Files.lines(path)) {
+            seedTransformer = parseToSeedTransformer(lines.toList());
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        System.out.println("Solution part one: " + seedTransformer.findLowestLocationNumber());
+        System.out.println("running part two...");
+        System.out.println("Solution part two: " + seedTransformer.findLowestLocationNumberSeedsAreRanges());
+        System.out.println("done...");
+
+        //Todo make a shortcut map from seed -> location
+        // run the numbers that are mapped thru the shortcut map, the ones that are unmapped -> just take the min...
+        // flatmapping from seed to location
+    }
+
+    private static SeedTransformer parseToSeedTransformer(List<String> inputLines) {
+        List<Long> seeds = Arrays.stream(inputLines.get(0).split(":")[1].split(" ")).filter(chunk -> !chunk.isBlank()).map(Long::parseLong).collect(Collectors.toList());
+        LinkedHashMap<AlmanacEntries, Set<AlmanacRangeMap>> almanacEntryToRangeMap = new LinkedHashMap<>();
+        almanacEntryToRangeMap.put(AlmanacEntries.SEED_TO_SOIL, new HashSet<>());
+        almanacEntryToRangeMap.put(AlmanacEntries.SOIL_TO_FERTILIZER, new HashSet<>());
+        almanacEntryToRangeMap.put(AlmanacEntries.FERTILIZER_TO_WATER, new HashSet<>());
+        almanacEntryToRangeMap.put(AlmanacEntries.WATER_TO_LIGHT, new HashSet<>());
+        almanacEntryToRangeMap.put(AlmanacEntries.LIGHT_TO_TEMPERATURE, new HashSet<>());
+        almanacEntryToRangeMap.put(AlmanacEntries.TEMPERATURE_TO_HUMIDITY, new HashSet<>());
+        almanacEntryToRangeMap.put(AlmanacEntries.HUMIDITY_TO_LOCATION, new HashSet<>());
+
+        AlmanacEntries currentAlmanacEntryEntries = null;
+        for (String line : inputLines.subList(1, inputLines.size())) {
+            if(line.isBlank()) {
+                continue;
+            }
+            if(line.matches("[0-9].*")) {
+                almanacEntryToRangeMap.get(currentAlmanacEntryEntries).add(parseToRangeMap(line));
+                continue;
+            }
+            // not a number nor blank, switch to new almanac entry.
+            Optional<AlmanacEntries> almanacEntry = AlmanacEntries.findAlmanacEntry(line);
+            currentAlmanacEntryEntries = almanacEntry.get();
+        }
+        return new SeedTransformer(seeds, almanacEntryToRangeMap);
+    }
+
+    public record SeedTransformer(List<Long> seeds, LinkedHashMap<AlmanacEntries, Set<AlmanacRangeMap>> almanacEntryToRangeMap) {
+
+        public Long findLowestLocationNumber() {
+            long min = Long.MAX_VALUE;
+            for (Long seed : seeds) {
+                long currentSourceNumber = seed;
+                for (Set<AlmanacRangeMap> almanacRangeMapForAlmanacEntry : almanacEntryToRangeMap.values()) {
+                    for (AlmanacRangeMap almanacRangeMap : almanacRangeMapForAlmanacEntry) {
+                        if (almanacRangeMap.isMapped(currentSourceNumber)) {
+                            currentSourceNumber = almanacRangeMap.findDestinationNumber(currentSourceNumber);
+                            break; // Match found, no need to test other rangemaps in this almanac entry
+                        }
+                    }
+                    // if no mapping found source is presumed to be same as destination, explanation:
+                    // Any source numbers that aren't mapped correspond to the same destination number. So, seed number 10 corresponds to soil number 10.
+                }
+                // at the end sourcenumber has become the location, compare it with min:
+                min = Math.min(min, currentSourceNumber);
+            }
+            return min;
+        }
+
+        public Long findLowestLocationNumberSeedsAreRanges() {
+            long min = Long.MAX_VALUE;
+            // TODO: yeah this actually requires some thought, imma head out :-)
+            return min;
+        }
+
+
+
+        public List<SeedRangeMap> seedsInterpretedAsRanges() {
+            List<SeedRangeMap> seedRangeMapList = new ArrayList<>();
+            for (int i = 0; i < seeds.size(); i = i + 2) {
+                seedRangeMapList.add(new SeedRangeMap(seeds.get(i), seeds.get(i+1)));
+            }
+            return seedRangeMapList;
+        }
+
+    }
+    public record SeedRangeMap(long start, long range) {
+
+        public long getLowerBound() {
+            return start;
+        }
+
+        public long getUpperBound() {
+            return start + range - 1;
+        }
+    }
+
+    private static AlmanacRangeMap parseToRangeMap(String line) {
+        List<Long> numbers = Arrays.stream(line.split(" ")).filter(chunk -> !chunk.isBlank()).map(Long::parseLong).toList();
+        return new AlmanacRangeMap(numbers.get(1), numbers.get(0), numbers.get(2));
+    }
+    public enum AlmanacEntries {
+        SEED_TO_SOIL("seed-to-soil"),
+        SOIL_TO_FERTILIZER("soil-to-fertilizer"),
+        FERTILIZER_TO_WATER("fertilizer-to-water"),
+        WATER_TO_LIGHT("water-to-light"),
+        LIGHT_TO_TEMPERATURE("light-to-temperatur"),
+        TEMPERATURE_TO_HUMIDITY("temperature-to-humidity"),
+        HUMIDITY_TO_LOCATION("humidity-to-location");
+
+        private String inputLabel;
+        AlmanacEntries(String inputLabel) {
+            this.inputLabel = inputLabel;
+        }
+
+        public static Optional<AlmanacEntries> findAlmanacEntry(String inputLine) {
+            return Arrays.stream(AlmanacEntries.values()).filter(a -> inputLine.contains(a.inputLabel)).findFirst();
+        }
+    }
+    public record AlmanacRangeMap(Long sourceNumberStart, Long destinationNumberStart, Long range) {
+
+
+        public boolean isMapped(Long sourceNumber) {
+            return sourceNumber >= sourceNumberStart && sourceNumber <= sourceNumberStart + range - 1;
+        }
+
+        public Long findDestinationNumber(Long sourceNumber) {
+            Long offsetFromStart = sourceNumber - sourceNumberStart;
+            return destinationNumberStart + offsetFromStart;
+        }
+    }
+
+    //TODO: what about a seed-to-location map?
+}
Index: src/main/java/com/wdtr/aoc/_2023/Problem6.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Problem6.java b/src/main/java/com/wdtr/aoc/_2023/Problem6.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Problem6.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,60 @@
+package com.wdtr.aoc._2023;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.stream.Stream;
+
+public class Problem6 {
+
+    public static void main(String[] args) {
+        String filePath = "src/main/resources/aoc-2023/problem6/input.txt";
+        Path path = Path.of(filePath);
+        List<Race> racesPartOne = null;
+        Race racePartTwo = null;
+        try (Stream<String> lines = Files.lines(path)) {
+            List<String> list = lines.toList();
+            racesPartOne = parseRacesPartOne(list);
+            racePartTwo = parseRacePartTwo(list);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        System.out.println("Solution part one: " + racesPartOne.stream().map(Race::getNumbersOfWayToBeatRecord).reduce(1L, (a, b) -> a * b));
+        System.out.println("Solution part two: " + racePartTwo.getNumbersOfWayToBeatRecord());
+
+
+
+    }
+
+    private static Race parseRacePartTwo(List<String> lines) {
+        long time = Long.parseLong(lines.get(0).split(":")[1].replace(" ", ""));
+        long distance = Long.parseLong(lines.get(1).split(":")[1].replace(" ", ""));
+        return new Race(time, distance);
+    }
+
+    private static List<Race> parseRacesPartOne(List<String> lines) {
+        List<Race> races = new ArrayList<>();
+        List<Long> times = Arrays.stream(lines.get(0).split(":")[1].split(" ")).filter(c -> !c.isBlank()).map(Long::parseLong).toList();
+        List<Long> distances = Arrays.stream(lines.get(1).split(":")[1].split(" ")).filter(c -> !c.isBlank()).map(Long::parseLong).toList();
+        for (int i = 0; i < times.size(); i++) {
+            races.add(new Race(times.get(i), distances.get(i)));
+        }
+        return races;
+    }
+
+    public record Race(long timeAllowed, long distanceRecord) {
+
+        public long getNumbersOfWayToBeatRecord() {
+            long numWays = 0;
+            for(long i = 1; i < timeAllowed; i++) {
+                long timeLeft = timeAllowed - i;
+                if(timeLeft * i > distanceRecord) {
+                    numWays++;
+                }
+            }
+            return numWays;
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/com/wdtr/aoc/_2023/Problem7.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Problem7.java b/src/main/java/com/wdtr/aoc/_2023/Problem7.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Problem7.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,194 @@
+package com.wdtr.aoc._2023;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class Problem7 {
+
+    public static void main(String[] args) {
+        String filePath = "src/main/resources/aoc-2023/problem7/input.txt";
+        Path path = Path.of(filePath);
+        List<HandWithBid> handWithBids = null;
+        try (Stream<String> lines = Files.lines(path)) {
+            List<String> list = lines.toList();
+            handWithBids = parseHandsWithBids(list);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        Comparator<HandWithBid> handWithBidComparator = Comparator.comparing(HandWithBid::hand).reversed();
+        Collections.sort(handWithBids, handWithBidComparator);
+        int bidSum = 0;
+        for (int i = 0; i < handWithBids.size(); i++) {
+            bidSum += (i + 1) * handWithBids.get(i).bid();
+        }
+        System.out.println("Solution part one: " + bidSum);
+
+
+
+    }
+
+    private static List<HandWithBid> parseHandsWithBids(List<String> lines) {
+        return lines.stream().map(l -> new HandWithBid(parseHand(l.split(" ")[0]), Integer.parseInt(l.split(" ")[1]))).collect(Collectors.toList());
+    }
+
+    private static Hand parseHand(String handString) {
+        List<Card> cards = new ArrayList<>();
+        char[] chars = handString.toCharArray();
+        for (int i = 0; i < chars.length; i++) {
+            cards.add(Card.from(chars[i]));
+        }
+        return Hand.from(cards);
+    }
+
+
+    public record HandWithBid(Hand hand, int bid) {
+
+    }
+
+    public record Hand(List<Card> cards, Map<Card, Integer> freqMap) implements Comparable<Hand>{
+
+
+        public static Hand from(List<Card> cards) {
+            return new Hand(cards, calculateFreqMap(cards));
+        }
+
+        private static Map<Card, Integer> calculateFreqMap(List<Card> cards) {
+            Map<Card, Integer> freqMap = new HashMap<>();
+            for (Card card : cards) {
+                freqMap.put(card, freqMap.getOrDefault(card, 0) + 1);
+            }
+            return freqMap;
+        }
+
+        @Override
+        public int compareTo(Hand o) {
+            int comparedHandTypes = this.calculateHandType().compareTo(o.calculateHandType());
+            if(comparedHandTypes == 0) {
+                // Second rule: order by card strength, first to last
+                List<Card> otherCards = o.cards;
+                for (int i = 0; i < cards.size(); i++) {
+                    int comparedCards = cards.get(i).compareTo(otherCards.get(i));
+                    if(comparedCards != 0) {
+                        return comparedCards;
+                    }
+                }
+                return 0;
+            }
+            return comparedHandTypes;
+        }
+
+
+        public HandType calculateHandType() {
+            if(isFiveOfAKind()) {
+                return HandType.FIVE_OF_A_KIND;
+            }
+            if(isFourOfAKind()) {
+                return HandType.FOUR_OF_A_KIND;
+            }
+            if(isFullHouse()) {
+                return HandType.FULL_HOUSE;
+            }
+            if(isThreeOfAKind()) {
+                return HandType.THREE_OF_A_KIND;
+            }
+            if(isTwoPair()) {
+                return HandType.TWO_PAIR;
+            }
+            if(isPair()) {
+                return HandType.ONE_PAIR;
+            }
+            return HandType.HIGH_CARD;
+        }
+        public boolean isFiveOfAKind() {
+            return freqMap.containsValue(5);
+        }
+
+        public boolean isFourOfAKind() {
+            return freqMap.containsValue(4);
+        }
+
+        public boolean isFullHouse() {
+            return isThreeOfAKind() && isPair();
+
+        }
+
+        public boolean isThreeOfAKind() {
+            return freqMap.containsValue(3);
+        }
+
+        public boolean isTwoPair() {
+            int pairCount = 0;
+            for (Integer value : freqMap.values()) {
+                if(value == 2) {
+                    pairCount++;
+                }
+            }
+            return pairCount == 2;
+        }
+
+        public boolean isPair() {
+            return freqMap.containsValue(2);
+        }
+
+
+    }
+
+
+    public enum HandType {
+        FIVE_OF_A_KIND,
+        FOUR_OF_A_KIND,
+        FULL_HOUSE,
+        THREE_OF_A_KIND,
+        TWO_PAIR,
+        ONE_PAIR,
+        HIGH_CARD,
+        ;
+
+
+
+    }
+
+    public enum Card {
+        ACE,
+        KING,
+        QUEEN,
+        JACK,
+        TEN,
+        NINE,
+        EIGHT,
+        SEVEN,
+        SIX,
+        FIVE,
+        FOUR,
+        THREE,
+        TWO,
+        ONE;
+
+        public static Card from(char c) {
+            return switch (c) {
+                case '1' -> ONE;
+                case '2' -> TWO;
+                case '3' -> THREE;
+                case '4' -> FOUR;
+                case '5' -> FIVE;
+                case '6' -> SIX;
+                case '7' -> SEVEN;
+                case '8' -> EIGHT;
+                case '9' -> NINE;
+                case 'T' -> TEN;
+                case 'J' -> JACK;
+                case 'Q' -> QUEEN;
+                case 'K' -> KING;
+                case 'A' -> ACE;
+                default -> throw new IllegalArgumentException("Wrong input");
+            };
+        }
+
+
+    }
+}
\ No newline at end of file
Index: src/main/java/com/wdtr/aoc/_2023/Problem7PartTwo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Problem7PartTwo.java b/src/main/java/com/wdtr/aoc/_2023/Problem7PartTwo.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Problem7PartTwo.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,265 @@
+package com.wdtr.aoc._2023;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import static com.wdtr.aoc._2023.Problem7PartTwo.Card.*;
+
+public class Problem7PartTwo {
+
+    public static void main(String[] args) {
+        String filePath = "src/main/resources/aoc-2023/problem7/input.txt";
+        Path path = Path.of(filePath);
+        List<HandWithBid> handWithBids = null;
+        try (Stream<String> lines = Files.lines(path)) {
+            List<String> list = lines.toList();
+            handWithBids = parseHandsWithBids(list);
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        Comparator<Hand> handComparator = Hand.handTypeComparator().thenComparing(Hand.cardByCardComparisonComparator()).reversed();
+        handWithBids.sort(((o1, o2) -> handComparator.compare(o1.hand, o2.hand)));
+
+        int bidSum = 0;
+        for (int i = 0; i < handWithBids.size(); i++) {
+            HandWithBid handWithBid = handWithBids.get(i);
+            bidSum += (i + 1) * handWithBid.bid();
+        }
+        System.out.println("Solution part two: " + bidSum);
+    }
+
+    private static List<HandWithBid> parseHandsWithBids(List<String> lines) {
+        return lines.stream().map(l -> new HandWithBid(parseHand(l.split(" ")[0]), Integer.parseInt(l.split(" ")[1]))).collect(Collectors.toList());
+    }
+
+    private static Hand parseHand(String handString) {
+        List<Card> cards = new ArrayList<>();
+        char[] chars = handString.toCharArray();
+        for (int i = 0; i < chars.length; i++) {
+            cards.add(Card.from(chars[i]));
+        }
+        return Hand.from(cards);
+    }
+
+
+    public record HandWithBid(Hand hand, int bid) {
+
+    }
+
+    public record Hand(List<Card> cards, Map<Card, Integer> freqMap) {
+
+
+        public static Hand from(List<Card> cards) {
+            return new Hand(cards, calculateFreqMap(cards));
+        }
+
+        private static Map<Card, Integer> calculateFreqMap(List<Card> cards) {
+            Map<Card, Integer> freqMap = new HashMap<>();
+            for (Card card : cards) {
+                freqMap.put(card, freqMap.getOrDefault(card, 0) + 1);
+            }
+            return freqMap;
+        }
+
+        public static Comparator<Hand> handTypeComparator() {
+            return (h1, h2) -> {
+                HandType handTypeH1 = h1.calculateHandType();
+                HandType handTypeH2 = h2.calculateHandType();
+                return handTypeH1.compareTo(handTypeH2);
+            };
+        }
+
+        public static Comparator<Hand> cardByCardComparisonComparator() {
+
+            return (h1, h2) -> {
+                for (int i = 0; i < h1.cards.size(); i++) {
+                    Card card1 = h1.cards.get(i);
+                    Card card2 = h2.cards.get(i);
+                    int comparedCards = card1.compareTo(card2);
+                    if(comparedCards != 0) {
+                        return comparedCards;
+                    }
+                }
+                return 0;
+            };
+        }
+
+        public HandType calculateHandType() {
+            /*
+             The isolated checking logic in the methods isn't foolproof.
+             Technically in the implemented logic a five of a kind is ALSO a pair, but since the method early returns we'll never have to worry about that.
+            */
+            if(isFiveOfAKind()) {
+                return HandType.FIVE_OF_A_KIND;
+            }
+            if(isFourOfAKind()) {
+                return HandType.FOUR_OF_A_KIND;
+            }
+            if(isFullHouse()) {
+                return HandType.FULL_HOUSE;
+            }
+            if(isThreeOfAKind()) {
+                return HandType.THREE_OF_A_KIND;
+            }
+            if(isTwoPair()) {
+                return HandType.TWO_PAIR;
+            }
+            if(isPair()) {
+                return HandType.ONE_PAIR;
+            }
+            return HandType.HIGH_CARD;
+        }
+        public boolean isFiveOfAKind() {
+            boolean fourOfAKindWithoutJoker = valuesWithoutJokers().contains(4);
+            boolean threeOfAKindWithoutJoker = valuesWithoutJokers().contains(3);
+            boolean pairWithoutJoker = valuesWithoutJokers().contains(2);
+
+            if(jokerCount() == 4) {
+                return true;
+            }
+            if(jokerCount() == 3 && pairWithoutJoker) {
+                return true;
+            }
+            if(jokerCount() == 2 && threeOfAKindWithoutJoker) {
+                return true;
+            }
+
+            if(jokerCount() == 1 && fourOfAKindWithoutJoker) {
+                return true;
+            };
+            return freqMap.containsValue(5);
+        }
+
+        public boolean isFourOfAKind() {
+            boolean threeOfAKindWithoutJoker = valuesWithoutJokers().contains(3);
+            boolean pairWithoutJoker = valuesWithoutJokers().contains(2);
+
+            if(jokerCount() == 3) {
+                return true;
+            }
+            if(jokerCount() == 2 && pairWithoutJoker) {
+                return true;
+            }
+
+            if(jokerCount() == 1 && threeOfAKindWithoutJoker) {
+                return true;
+            }
+            return freqMap.containsValue(4);
+        }
+
+        public boolean isFullHouse() {
+            // KKJ55
+            boolean pairWithoutJoker = valuesWithoutJokers().contains(2);
+            boolean threeOfAKindWithoutJoker = valuesWithoutJokers().contains(3);
+            // JJ223
+            if(jokerCount() == 2 && pairWithoutJoker) {
+                return true;
+            }
+            // J2223
+            boolean twoPairWithoutJoker = valuesWithoutJokers().stream().filter(v -> v == 2).count() == 2;
+            if(jokerCount() == 1 && twoPairWithoutJoker) {
+                return true;
+            }
+            return threeOfAKindWithoutJoker && pairWithoutJoker;
+        }
+
+        public boolean isThreeOfAKind() {
+            boolean pairWithoutJoker = valuesWithoutJokers().contains(2);
+            boolean threeOfAKindWithoutJoker = valuesWithoutJokers().contains(3);
+
+            // JJ456
+            if(jokerCount() == 2) {
+                return true;
+            }
+            // J4456
+            if(jokerCount() == 1 && pairWithoutJoker) {
+                return true;
+            }
+            return threeOfAKindWithoutJoker;
+        }
+
+        // if there is a joker, you will either have a pair or a better hand than two pair
+        public boolean isTwoPair() {
+            // 22445
+            return valuesWithoutJokers().stream().filter(v -> v == 2).count() == 2;
+        }
+
+        public boolean isPair() {
+            if(jokerCount() == 1) {
+                return true;
+            }
+            return valuesWithoutJokers().contains(2);
+        }
+
+        public int jokerCount() {
+            return freqMap.getOrDefault(JOKER, 0);
+        }
+
+
+        public Collection<Integer> valuesWithoutJokers() {
+            List<Integer> valuesWithoutJoker = new ArrayList<>();
+            for (Card card : freqMap.keySet()) {
+                if(card.isNotJoker()) {
+                    valuesWithoutJoker.add(freqMap.get(card));
+                }
+            }
+            return valuesWithoutJoker;
+        }
+    }
+
+
+    public enum HandType {
+        FIVE_OF_A_KIND,
+        FOUR_OF_A_KIND,
+        FULL_HOUSE,
+        THREE_OF_A_KIND,
+        TWO_PAIR,
+        ONE_PAIR,
+        HIGH_CARD,
+
+    }
+
+    public enum Card {
+        ACE,
+        KING,
+        QUEEN,
+        TEN,
+        NINE,
+        EIGHT,
+        SEVEN,
+        SIX,
+        FIVE,
+        FOUR,
+        THREE,
+        TWO,
+        JOKER;
+        public static Card from(char c) {
+            return switch (c) {
+                case '2' -> TWO;
+                case '3' -> THREE;
+                case '4' -> FOUR;
+                case '5' -> FIVE;
+                case '6' -> SIX;
+                case '7' -> SEVEN;
+                case '8' -> EIGHT;
+                case '9' -> NINE;
+                case 'T' -> TEN;
+                case 'J' -> JOKER;
+                case 'Q' -> QUEEN;
+                case 'K' -> KING;
+                case 'A' -> ACE;
+                default -> throw new IllegalArgumentException("Wrong input");
+            };
+        }
+
+
+        public boolean isNotJoker() {
+            return !this.equals(JOKER);
+        }
+    }
+}
\ No newline at end of file
Index: src/main/java/com/wdtr/aoc/_2023/Problem8.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/com/wdtr/aoc/_2023/Problem8.java b/src/main/java/com/wdtr/aoc/_2023/Problem8.java
new file mode 100644
--- /dev/null	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
+++ b/src/main/java/com/wdtr/aoc/_2023/Problem8.java	(revision 7e717c4dd792263dea8a3e8db3fa4b4ae3ec21aa)
@@ -0,0 +1,153 @@
+package com.wdtr.aoc._2023;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+
+import static com.wdtr.aoc._2023.Problem8.Direction.LEFT;
+
+public class Problem8 {
+
+    public static void main(String[] args) throws IOException {
+        String filePath = "src/main/resources/aoc-2023/problem8/input.txt";
+        Path path = Path.of(filePath);
+
+        Map<String, Node> idToNodeMap = new HashMap<>();
+        List<String> lines = Files.lines(path).toList();
+        List<Direction> route = parseRoute(lines.get(0));
+        for (String nodeLine : lines.subList(2, lines.size())) {
+            parseNode(nodeLine, idToNodeMap);
+        }
+
+
+        // QXA
+        // PDA
+        // TDA
+        // QQA
+        // PPA
+        // AAA
+
+        // HLZ
+        // PXZ
+        // VJZ
+        // NBZ
+        // XBZ
+        // ZZZ
+        // Cycle detection + ggd
+        System.out.println("Solution part one: " + countPathLengthFromNodeToNodeUsingRoute(route, idToNodeMap.get("AAA"), idToNodeMap.get("ZZZ")));
+        List<Node> nodesEndingInA = new ArrayList<>();
+        List<Node> nodesEndingInZ = new ArrayList<>();
+        for (String idNode : idToNodeMap.keySet()) {
+            if(idNode.endsWith("A")) {
+                nodesEndingInA.add(idToNodeMap.get(idNode));
+            }
+            if(idNode.endsWith("Z")) {
+                nodesEndingInZ.add(idToNodeMap.get(idNode));
+            }
+        }
+    }
+
+    private static int countPathLengthFromNodeToNodeUsingRoute(List<Direction> route, Node beginNode, Node endNode) {
+        Node currentNode = beginNode;
+        int hops = 0;
+        while(!currentNode.nodeId.equals(endNode.nodeId)) {
+            Direction direction = route.get(hops % route.size());
+            if(direction == LEFT) {
+                currentNode = currentNode.left;
+            } else {
+                currentNode = currentNode.right;
+            }
+            hops++;
+        }
+        return hops;
+    }
+
+
+
+
+    private static List<Direction> parseRoute(String routeString) {
+        List<Direction> route = new ArrayList<>();
+        for (char currChar : routeString.toCharArray()) {
+            if (currChar == 'L') {
+                route.add(LEFT);
+            } else if (currChar == 'R') {
+                route.add(Direction.RIGHT);
+            }
+        }
+        return route;
+    }
+
+    private static void parseNode(String nodeLine, Map<String, Node> idToNodeMap) {
+        // CTK = (JLT, HRF)
+        String[] split = nodeLine.split("=");
+        String nodeId = split[0].trim();
+        String[] neighbors = split[1].replace("(", "").replace(")", "").split(",");
+        String leftNeighborId = neighbors[0].trim();
+        String rightNeighborId = neighbors[1].trim();
+        Node currentNode = createIfNotExists(nodeId, idToNodeMap);
+        Node leftNode = createIfNotExists(leftNeighborId, idToNodeMap);
+        Node rightNode = createIfNotExists(rightNeighborId, idToNodeMap);
+        currentNode.setLeft(leftNode);
+        currentNode.setRight(rightNode);
+    }
+
+    public static Node createIfNotExists(String nodeId, Map<String, Node> idToNodeMap) {
+        if(idToNodeMap.containsKey(nodeId)) {
+            return idToNodeMap.get(nodeId);
+        }
+        Node newNode = new Node(nodeId, null, null);
+        idToNodeMap.put(nodeId, newNode);
+        return newNode;
+    }
+
+    public enum Direction {
+        LEFT,
+        RIGHT
+    }
+
+    public static final class Node {
+        private final String nodeId;
+        private Node left;
+        private Node right;
+
+        public Node(String nodeId, Node left, Node right) {
+            this.nodeId = nodeId;
+            this.left = left;
+            this.right = right;
+        }
+
+
+
+        public void setLeft(Node left) {
+            this.left = left;
+        }
+
+
+        public void setRight(Node right) {
+            this.right = right;
+        }
+
+        @Override
+        public boolean equals(Object obj) {
+            if (obj == this) return true;
+            if (obj == null || obj.getClass() != this.getClass()) return false;
+            var that = (Node) obj;
+            return Objects.equals(this.nodeId, that.nodeId) &&
+                    Objects.equals(this.left, that.left) &&
+                    Objects.equals(this.right, that.right);
+        }
+
+        @Override
+        public int hashCode() {
+            return Objects.hash(nodeId, left, right);
+        }
+
+        @Override
+        public String toString() {
+            return  nodeId;
+        }
+
+
+        }
+}
\ No newline at end of file
